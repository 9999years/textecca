use std::collections::HashMap;
use std::ops::{Deref, DerefMut};
use std::vec;

use super::blocks::*;
use super::inlines::*;

/// Some metadata to be associated with a group of blocks or inlines; metadata is
/// currently unstructured and its representation will almost certainly change in
/// the future.
pub type Meta = HashMap<String, String>;

/// An entire document.
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Doc {
    /// Document metadata.
    pub meta: DocMeta,
    /// Document content.
    pub content: Blocks,
}

/// Document metadata.
pub type DocMeta = HashMap<String, String>;

impl Doc {
    /// Create a document from the given `Blocks`.
    pub fn from_content(content: Blocks) -> Self {
        Self {
            content,
            ..Default::default()
        }
    }

    /// Does this document contain any math blocks or inlines?
    pub fn has_math(&self) -> bool {
        // TODO: An actual tree-traversal.
        true
    }

    /// Recursively visit the blocks in this document to resolve all references.
    ///
    /// Returns a map of String -> Ref generated by the visitor function, or a
    /// Vec<String> of unresolved references.
    pub fn visit_references<F, Ref>(&self, visit: F) -> Result<HashMap<String, Ref>, Vec<String>>
    where
        F: Fn(BlockInner) -> Ref,
    {
        todo!()
    }

    /// Call a function on each `Block` in this document, recursively.
    ///
    /// Note that because this function handles traversal, the visitor function
    /// shouldn't attempt to traverse the tree of blocks it visits.
    pub fn visit_inorder_iter<'s, F, R>(&'s self, visit: F) -> impl Iterator<Item = R> + 's
    where
        F: FnMut(&BlockInner) -> R,
        R: 's,
    {
        todo!();
        #[allow(unreachable_code)] // let this typecheck
        std::iter::empty() // let this typecheck
    }
}

/// A sequence of `Block`s.
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Blocks(pub Vec<Block>);

impl Deref for Blocks {
    type Target = Vec<Block>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Blocks {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl IntoIterator for Blocks {
    type Item = Block;
    type IntoIter = std::vec::IntoIter<Block>;
    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Into<Vec<Block>> for Blocks {
    fn into(self) -> Vec<Block> {
        self.0
    }
}

impl From<Vec<Block>> for Blocks {
    fn from(v: Vec<Block>) -> Self {
        Self(v)
    }
}

impl From<Block> for Blocks {
    fn from(b: Block) -> Self {
        Self(vec![b])
    }
}

/// A `Block` identifier, unique within a `Doc` and monotonically increasing.
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Default)]
pub struct Id(usize);

impl From<usize> for Id {
    fn from(id: usize) -> Self {
        Self(id)
    }
}

impl Iterator for Id {
    type Item = Id;
    fn next(&mut self) -> Option<Self::Item> {
        Some(Id(self.0 + 1))
    }
}

/// A block of content within a document.
///
/// The actual content lives in the `inner` field.
#[derive(Debug, Clone, PartialEq)]
pub struct Block {
    /// A document-unique `Id`.
    pub id: Id,
    /// The content.
    pub inner: BlockInner,
}

impl Deref for Block {
    type Target = BlockInner;
    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl DerefMut for Block {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

/// A block of content within a document, typically separated by vertical space.
#[derive(Debug, Clone, PartialEq)]
pub enum BlockInner {
    /// Text not in a paragraph; this is treated as `Inlines`, but in a block context.
    Plain(Inlines),

    /// Paragraph.
    Par(Inlines),

    /// Code block.
    Code(Code),

    /// Block quote.
    Quote(Blocks),

    /// An ordered (numbered) or unordered (bulleted) list.
    List(List),

    /// A definition list, matching terms to their definitions.
    TermList(Vec<TermListItem>),

    /// A heading, or more accurately a document division.
    Heading(Heading),

    /// Horizontal rule.
    Rule,

    /// A table.
    Table(Table),

    /// A figure-like block; a diagram, image, or similar.
    Figure(Figure),

    /// A concept; this could be a warning, definition, note, theorem, etc.
    Defn(Defn),

    /// Display math
    Math(Math),
}

/// A sequence of `Inline`s.
pub type Inlines = Vec<Inline>;

/// A span of inline content in a document.
#[derive(Debug, Clone, PartialEq)]
pub enum Inline {
    /// Plain text.
    Text(String),

    /// Style instruction.
    Styled {
        /// The style the text is tagged with.
        style: Style,
        /// The contained text.
        content: Inlines,
    },

    /// An inline quotation.
    Quote(Quote),

    /// Inline code span.
    Code(InlineCode),

    /// Inter-word space.
    ///
    /// TODO: How to handle inter-sentence spacing?
    Space,

    /// A link, either intra-document or external.
    Link(Link),

    /// A footnote.
    ///
    /// TODO: Endnotes, footnote positioning, end-of-chapter notes...?
    Footnote(Footnote),

    /// Mathematics.
    Math(InlineMath),
}
